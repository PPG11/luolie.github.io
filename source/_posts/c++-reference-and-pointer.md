---
title: C++ 引用和指针
top: false
cover: false
toc: true
mathjax: true
date: 2019-03-11 10:09:29
password:
summary:
tags:
- C/C++
categories:
- [面试]
---

指针对于一个类型`T`，`T*`就是指向`T`的指针类型，也即一个`T*`类型的变量能够保存一个`T`对象的**地址**，而类型`T`是可以加一些限定词的，如`const`、`volatile`等等。

## 1. 为什么C/C++语言使用指针？

原文链接：https://www.cnblogs.com/gxcdream/p/4805612.html

1. 一方面，每一种编程语言都使用指针。不止C/C++使用指针。

> 每一种编程语言都使用指针。C++将指针暴露给了用户(程序员)，而Java和C#等语言则将指针隐藏起来了。
> "Everything uses pointers. C++ just exposes them rather than hiding them,"
> It's easier to give someone an address to your home than to give a copy of your home to everyone.

2. 另一方面
使用指针的优点和必要性：
- 指针能够有效的表示数据结构；
- 能动态分配内存，实现内存的自由管理；
- 能较方便的使用字符串；
- 便捷高效地使用数组
- 指针直接与数据的储存地址有关，比如：值传递不如地址传递高效，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下（注意：形参的改变会影响实参的值！）

## 引用和指针有什么区别？

本质：引用是别名，指针是地址

具体的：

1. 从现象上看，指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。

> 这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。

2. 从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。

> 注：标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器 http://bbs.csdn.net/topics/320095541

3. 从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。

> 指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。
> 符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。
> 这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。

4. 不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。

> 因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空(野指针)。

5. 理论上，对于指针的级数没有限制，但是引用只能是一级。如下：

```c++
  int** p1;         // 合法。指向指针的指针
  int*& p2;         // 合法。指向指针的引用
  int&* p3;         // 非法。指向引用的指针是非法的
  int&& p4;         // 非法。指向引用的引用是非法的
```

**注意上述读法是从左到右**。 
 

## 特别之处`const`

为什么要提到`const`关键字呢？因为`const`对指针和引用的限定是有差别的：

### 常量指针 & 常量引用

**顶层`const` (top-level `const`)**

```c++
const int* pointer = &a
```
 
1. 常量指针：指向常量的指针，在**指针定义语句的类型前**加const，表示指向的对象是常量。

定义指向常量的指针只限制指针的间接访问操作，而不能规定指针指向的值本身的操作规定性。

常量指针定义`const int* pointer = &a`告诉编译器，`*pointer`是常量，不能将`*pointer`作为左值进行操作。


2. 常量引用：指向常量的引用，在引用定义语句的类型前加`const`，表示指向的对象是常量。

也跟指针一样不能对引用指向的变量进行重新赋值操作。


### 指针常量 & 引用常量

**底层`const` (low-level `const`)**

```c++
int* const pointer = &a
```

在**指针定义语句的指针名前**加`const`，表示指针本身是常量。在定义指针常量时必须初始化！

而这是引用与生俱来的属性，无需使用const。

指针常量定义`int* const pointer = &b`告诉编译器，`pointer`(地址)是常量，不能作为左值进行操作，但是允许修改间接访问值，即`*pointer`（地址所指向内存的值）可以修改。


### 常量指针常量 & 常量引用常量

```c++
const int* const pointer = &a
```

告诉编译器，`pointer`和`*pointer`都是常量，他们都不能作为左值进行操作。
 
而不存在所谓的"常量引用常量"，因为引用变量就是引用常量。

`C++`不区分变量的`const`引用和`const`变量的引用。程序决不能给引用本身重新赋值，使他指向另一个变量，因此引用总是`const`的。如果对引用应用关键字`const`，起作用就是使其目标称为`const`变量。即

没有:`const double const& a = 1;`
只有:
```c++
const double& a = 1;
double b = 1;
const double& a = b;
b = 2; // 正确
a = 3; // error: assignment of read-only reference `a`
```

> 总结：有一个规则可以很好的区分`const`是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号（*），如果`const`
> 出现在线的左边，指针指向的数据为常量；如果`const`出现在右边，指针本身为常量。而引用本身就是常量，即不可以改变指向。
 
## 指针传递和引用传递

**指针传递**参数本质上是值传递的方式，它所传递的值是一个地址值。

```c++
int val = 1;
int* a = &val;

fun(*a);
// 此处仍然传递进去的是a的值，不会改变外面的
```

值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。

值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。


**引用传递**过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。

```c++
int val = 1;
int& a = val;

fun(a);
// 此处放进去的a如果改变可以改变外面的a
```

被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。

正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

> 引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量。
> 但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。
> 而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。
> 如果想通过指针参数传递来改变主调函数中的相关变量， 那就得使用指向指针的指针，或者指针引用。


从概念上讲

- 指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

- 引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。


 
## 参考文献：

http://bbs.csdn.net/topics/80358667
http://www.guokr.com/post/443914/
http://blog.csdn.net/listening_music/article/details/6921608
http://www.tc5u.com/cpp/2400451.htm