---
title: C++引用和指针的联系和区别
date: 2021-01-11 18:09:29
tags:
- C/C++
---

# 为什么C/C++语言使用指针？
原文链接：https://www.cnblogs.com/gxcdream/p/4805612.html

答案：①一方面，每一种编程语言都使用指针。不止C/C++使用指针。
每一种编程语言都使用指针。C++将指针暴露给了用户(程序员)，而Java和C#等语言则将指针隐藏起来了。
“Everything uses pointers. C++ just exposes them rather than hiding them,”
It's easier to give someone an address to your home than to give a copy of your home to everyone.
②另一方面
使用指针的优点和必要性：
指针能够有效的表示数据结构；
能动态分配内存，实现内存的自由管理；
能较方便的使用字符串；
便捷高效地使用数组
指针直接与数据的储存地址有关，比如：值传递不如地址传递高效，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下（注意：形参的改变会影响实参的值！）
引用和指针有什么区别？
本质：引用是别名，指针是地址，具体的：

①从现象上看，指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。
②从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。
注：标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器 http://bbs.csdn.net/topics/320095541
③ 从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。
④不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
⑤理论上，对于指针的级数没有限制，但是引用只能是一级。如下：
  int** p1;         // 合法。指向指针的指针
  int*& p2;         // 合法。指向指针的引用
  int&* p3;         // 非法。指向引用的指针是非法的
  int&& p4;         // 非法。指向引用的引用是非法的
  注意上述读法是从左到右。 
 

来源： <http://www.tc5u.com/cpp/2400451.htm>
 

 
下面用通俗易懂的话来概述一下：

指针-对于一个类型T，T*就是指向T的指针类型，也即一个T*类型的变量能够保存一个T对象的地址，而类型T是可以加一些限定词的，如const、volatile等等。见下图，所示指针的含义：


引用-引用是一个对象的别名，主要用于函数参数和返回值类型，符号X&表示X类型的引用。见下图，所示引用的含义：


首先，引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，引用为空——对象都不存在，怎么可能有别名！故定义一个引用的时候，必须初始化，不初始化的话连编译都通不过（编译时错误）。因此如果你有一个变量是用于指向另一个对象，但是它可能为空，这时你应该使用指针；如果变量总是指向一个对象，i.e.，你的设计不允许变量为空，这时你应该使用引用。
注意：正因为指针可以不指向任何对象，使用指针之前必须做判空操作，而引用就不必。
 
其次，引用不可以改变指向，对一个对象"至死不渝"；但是指针可以改变指向，而指向其它对象。说明：虽然引用不可以改变指向，但是可以改变初始化对象的内容。

例如就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容。
 
再次，引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针（地址）本身的大小，32位系统下，一般为4个字节。

 
最后，引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针）。
 
总之，可以归结为"指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向。"
特别之处const
为什么要提到const关键字呢？因为const对指针和引用的限定是有差别的：
常量指针VS常量引用
 
★常量指针：指向常量的指针，在指针定义语句的类型前加const，表示指向的对象是常量。
定义指向常量的指针只限制指针的间接访问操作，而不能规定指针指向的值本身的操作规定性。

 常量指针定义"const int* pointer=&a"告诉编译器，*pointer是常量，不能将*pointer作为左值进行操作。
 
★常量引用：指向常量的引用，在引用定义语句的类型前加const，表示指向的对象是常量。也跟指针一样不能对引用指向的变量进行重新赋值操作。

 
指针常量VS引用常量
 
在指针定义语句的指针名前加const，表示指针本身是常量。在定义指针常量时必须初始化！而这是引用与生俱来的属性，无需使用const。
 
指针常量定义"int* const pointer=&b"告诉编译器，pointer(地址)是常量，不能作为左值进行操作，但是允许修改间接访问值，即*pointer（地址所指向内存的值）可以修改。
 
常量指针常量VS常量引用常量
 
常量指针常量：指向常量的指针常量，可以定义一个指向常量的指针常量，它必须在定义时初始化。
定义"const int* const pointer=&c"
告诉编译器，pointer和*pointer都是常量，他们都不能作为左值进行操作。
 
而不存在所谓的"常量引用常量"，因为引用变量就是引用常量。C++不区分变量的const引用和const变量的引用。程序决不能给引用本身重新赋值，使他指向另一个变量，因此引用总是const的。如果对引用应用关键字const，起作用就是使其目标称为const变量。即
没有：const double const& a=1;
只有const double& a=1;
double b=1;
constdouble& a=b;
b=2;//正确
a=3;//出错error: assignment of read-only reference `a'
 
 
 
总结：有一个规则可以很好的区分const是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身就是常量，即不可以改变指向。
 
指针传递和引用传递
为了更好的理解指针和引用，下面介绍一下指针传递和引用传递。当指针和引用作为函数的参数是如何传值的呢？

指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
引用传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量， 那就得使用指向指针的指针，或者指针引用。

 

从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

 

 

 最后，总结一下指针和引用的相同点和不同点：

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

★不同点：

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；

●引用没有const，指针有const，const的指针不可变；

具体指没有int& const a这种形式，而const int& a是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

●引用不能为空，指针可以为空；

●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查）

 
参考文献：
http://bbs.csdn.net/topics/80358667
http://www.guokr.com/post/443914/
http://blog.csdn.net/listening_music/article/details/6921608
http://www.tc5u.com/cpp/2400451.htm